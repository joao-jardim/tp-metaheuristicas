#!/usr/bin/env python3
"""
Parse the `greedy_stats.csv` generated by the C++ heuristics and
write a structured JSON file `results/greedy_stats.json` for easier
programmatic consumption.

Usage:
  python3 scripts/parse_greedy_stats.py [--csv path/to/greedy_stats.csv] [--out path/to/output.json]

If no paths are provided, defaults to `greedy_stats.csv` in CWD and
`results/greedy_stats.json` for output.
"""
import argparse
import csv
import json
from pathlib import Path


def parse_file(path):
    sections = {}
    cur_section = "metrics"
    sections[cur_section] = []

    with open(path, newline='', encoding='utf-8') as fh:
        reader = csv.reader(fh)
        rows = list(reader)

    i = 0
    # Simple state machine: detect known section headers by content
    while i < len(rows):
        row = rows[i]
        if not row or all(not cell.strip() for cell in row):
            i += 1
            continue
        # detect section starts by a header-like row
        first = row[0].strip().lower()
        if first.startswith('prefer') or first.startswith('preferencias'):
            cur_section = 'preferences'
            # skip the header line and the column header
            i += 2
            sections[cur_section] = []
            continue
        if first.startswith('ocupacao por sala'.lower()) or first.startswith('ocupacao por sala'):
            cur_section = 'classroom_occupancy'
            # skip next line (column header)
            i += 2
            sections[cur_section] = []
            continue
        if first.startswith('ocupacao por dia'):
            cur_section = 'day_occupancy'
            i += 2
            sections[cur_section] = []
            continue
        if first.startswith('distribuicao desperdicio') or first[0:10].lower().find('desperdicio')>=0:
            cur_section = 'waste_distribution'
            i += 2
            sections[cur_section] = []
            continue
        if first.startswith('ocupacao por dia e horario') or first.startswith('ocupacao por dia e horario'):
            cur_section = 'schedule_occupancy'
            i += 2
            sections[cur_section] = []
            continue

        # fallback: if we are in metrics and see a header row 'Metrica,Valor'
        if cur_section == 'metrics' and len(row) >= 2 and row[0].strip().lower().startswith('metrica'):
            i += 1
            continue

        # parse according to current section
        if cur_section == 'metrics':
            if len(row) >= 2:
                sections['metrics'].append({'metric': row[0].strip(), 'value': try_number(row[1].strip())})
        elif cur_section == 'preferences':
            # expect: Categoria,Total,Satisfeitas,Taxa (%)
            if len(row) >= 4:
                sections['preferences'].append({
                    'category': row[0].strip(),
                    'total': try_int(row[1].strip()),
                    'satisfied': try_int(row[2].strip()),
                    'rate_pct': try_number(row[3].strip())
                })
        elif cur_section == 'classroom_occupancy':
            # ClassroomId,Encontros,Demanda,Capacidade,TaxaUtilizacao(%)
            if len(row) >= 5:
                sections['classroom_occupancy'].append({
                    'classroom_id': try_int(row[0].strip()),
                    'meetings': try_int(row[1].strip()),
                    'demand': try_int(row[2].strip()),
                    'capacity': try_int(row[3].strip()),
                    'util_pct': try_number(row[4].strip())
                })
        elif cur_section == 'day_occupancy':
            # DiaSemanaSemana,Encontros,Demanda
            if len(row) >= 3:
                sections['day_occupancy'].append({
                    'day': try_int(row[0].strip()),
                    'meetings': try_int(row[1].strip()),
                    'demand': try_int(row[2].strip())
                })
        elif cur_section == 'waste_distribution':
            # single column with waste values
            if len(row) >= 1 and row[0].strip():
                sections['waste_distribution'].append(try_int(row[0].strip()))
        elif cur_section == 'schedule_occupancy':
            # DiaSchedule,Demanda
            if len(row) >= 2:
                sections['schedule_occupancy'].append({
                    'day_schedule': row[0].strip(),
                    'demand': try_int(row[1].strip())
                })
        i += 1

    return sections


def try_int(s):
    try:
        return int(float(s))
    except Exception:
        return None


def try_number(s):
    try:
        return float(s)
    except Exception:
        return s


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--csv', '-c', default='greedy_stats.csv')
    parser.add_argument('--out', '-o', default='results/greedy_stats.json')
    args = parser.parse_args()

    csvp = Path(args.csv)
    outp = Path(args.out)
    if not csvp.exists():
        print(f"CSV file not found: {csvp.resolve()}")
        return

    outp.parent.mkdir(parents=True, exist_ok=True)
    parsed = parse_file(csvp)
    with outp.open('w', encoding='utf-8') as fh:
        json.dump(parsed, fh, indent=2, ensure_ascii=False)
    print(f"Wrote JSON to: {outp.resolve()}")


if __name__ == '__main__':
    main()
